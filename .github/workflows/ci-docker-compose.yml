name: Docker Swarm CI

on:
  push:
    branches-ignore:
      - main
  pull_request:
    branches:
      - main
      
      ###########################
      #      CONFIGURATION      #
      ###########################
jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Cloner le d√©p√¥t
        uses: actions/checkout@v4
  
      - name: ‚öôÔ∏è Configurer Docker Swarm
        run: docker swarm init || echo "Swarm d√©j√† initialis√© ou erreur ignor√©e"
      
      - name: ‚öôÔ∏è V√©rifier si Docker Swarm est bien actif
        run: docker info | grep -i swarm

      - name: üíæ Sauvegarder le workspace
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: |
            .
            .git/
          retention-days: 1

      - name: üõ† V√©rifier les artefacts apr√®s upload
        run: ls -la $GITHUB_WORKSPACE

  matrix_setup:
    needs: setup
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [elk, opencti, openbas]
    steps:
      - name: Cloner le d√©p√¥t
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è V√©rifier et configurer Docker Swarm
        run: |
          if [ "$(docker info --format '{{.Swarm.LocalNodeState}}')" != "active" ]; then
            echo "Swarm inactif, initialisation..."
            docker swarm init || true
          else
            echo "Swarm d√©j√† actif."
          fi

      - name: üîÑ Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: |
            .

      - name: üîé V√©rifier l'existence des fichiers Docker Compose
        run: |
          for service in ${{matrix.service}}; do
            if [[ ! -f "$service/docker-compose.yml" ]]; then
              echo "‚ùå Fichier manquant : $service/docker-compose.yml"
              exit 1
            fi
          done
      
      - name: üïµÔ∏è V√©rification de l'existence du fichier .env
        run: |
          ls -la ${{ matrix.service }}/
          cat ${{ matrix.service }}/.env || echo "‚ùå Fichier .env introuvable !"
      
      - name: üïµÔ∏è V√©rifier le chemin du `.env`
        run: find $GITHUB_WORKSPACE -name ".env"

      - name: üìÇ V√©rifier la pr√©sence du `.env`
        run: |
          echo "üìÇ Contenu du dossier ${{ matrix.service }} :"
          ls -la ${{ matrix.service }}/
          echo "üìÇ Contenu du r√©pertoire courant :"
          ls -la
      
      - name: üìÇ Copier `.env` sous un autre nom avant upload
        run: cp ${{ matrix.service }}/.env ${{ matrix.service }}/env_file_${{ matrix.service }}
    
      - name: üíæ Sauvegarder `.env`
        uses: actions/upload-artifact@v4
        with:
          name: env_file_${{ matrix.service }}
          path: ${{ matrix.service }}/env_file_${{ matrix.service }}
          if-no-files-found : warn

      - name: üõ† V√©rifier les artefacts apr√®s upload
        run: ls -la $GITHUB_WORKSPACE
        
  ###########################
  #      D√âPLOIEMENT        #
  ###########################
  deploy:
    needs: 
      - setup
      - matrix_setup
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:dind
        options: --privileged
    strategy:
      matrix:
        service: [elk, opencti, openbas]
    steps:
      - name: ‚öôÔ∏è V√©rifier et configurer Docker Swarm
        run: |
          if [ "$(docker info --format '{{.Swarm.LocalNodeState}}')" != "active" ]; then
            echo "Swarm inactif, initialisation..."
            docker swarm init || true
          else
            echo "Swarm d√©j√† actif."
          fi

      - name: üîÑ Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: |
            .

      - name: üîÑ Restaurer `.env`
        uses: actions/download-artifact@v4
        with:
          name: env_file_${{ matrix.service }}
          path: ${{ matrix.service }}/
          
      - name: üõ† V√©rifier `.env` apr√®s la r√©cup√©ration
        run: ls -la elk/
          
      - name: üöÄ D√©ployer ${{ matrix.service }}
        run: |
          echo "üîÑ D√©ploiement de ${{ matrix.service }}..."
    
          export $(grep -v '^#' ${{ matrix.service }}/env_file_${{ matrix.service }} | sed 's/\([^=]*\)=\(.*\)/\1="\2"/' | xargs)
    
          docker stack deploy -c ${{ matrix.service }}/docker-compose.yml ${{ matrix.service }} 2>&1 | tee logs_${{ matrix.service }}.txt
          sleep 10

          if [[ $? -ne 0 ]]; then
            echo "üö® Erreur lors du d√©ploiement de ${{ matrix.service }}"
            echo "test_failed=true" >> $GITHUB_ENV
          else
            echo "‚úÖ D√©ploiement r√©ussi pour ${{ matrix.service }}"
            echo "test_failed=false" >> $GITHUB_ENV
          fi
    
      - name: üì¶ Sauvegarder les logs si une erreur est d√©tect√©e
        if: env.test_failed == 'true'
        uses: actions/upload-artifact@v4
        with:
            name: logs_${{ matrix.service }}
            path: logs_${{ matrix.service }}.txt

  ###########################
  #  D√âTECTION DES ERREURS  #
  ###########################
  check_errors:
    needs: deploy
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [elk, opencti, openbas]
    outputs:
      test_failed: ${{ steps.detect_failure.outputs.test_failed }}
    steps:
      - name: üì• R√©cup√©rer les logs de ${{ matrix.service }} uniquement si une erreur est d√©tect√©e
        if: env.test_failed == 'true'
        uses: actions/download-artifact@v4
        with:
          name: logs_${{ matrix.service }}
          path: .

      - name: üîç V√©rifier les erreurs dans logs_${{ matrix.service }}.txt
        id: detect_failure
        run: |
          TEST_FAILED=false
          log_file="logs_${{ matrix.service }}.txt"
          
          # Si le fichier de logs existe, on analyse les erreurs dedans
          if [[ -f "$log_file" && $(grep -i "error\|failed\|cannot\|swarm manager" "$log_file" | grep -v "Creating service") ]]; then
            echo "‚ö†Ô∏è Erreur d√©tect√©e dans $log_file"
            TEST_FAILED=true
          fi
          
          echo "test_failed=$TEST_FAILED" >> $GITHUB_OUTPUT

  ###########################
  #   GESTION DES LOGS      #
  ###########################
  push_logs:
    needs: check_errors
    runs-on: ubuntu-latest
    steps:
      - name: üì• Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: üöÄ V√©rifier `.git/`
        run: |
          if [ ! -d ".git" ]; then
            echo "‚ö†Ô∏è Le dossier .git est manquant, reclonage en cours..."
            rm -rf ./*
            git clone https://github.com/${{ github.repository }}.git .
          fi

      - name: üì• T√©l√©charger tous les logs
        if: env.test_failed == 'true'
        uses: actions/download-artifact@v4
        with:
          path: logs/

      - name: üìù V√©rifier et g√©n√©rer un fichier de logs consolid√©
        run: |
          LOGS_FOUND=false
          echo "üìÖ Date : $(date)" > error-log.txt
          
          for service in wazuh elk opencti openbas; do
            log_file="logs/logs_$service/logs_$service.txt"
            
            if [[ -f "$log_file" ]]; then
              LOGS_FOUND=true
              echo "‚ùå ERREUR DE D√âPLOIEMENT POUR $service :" >> error-log.txt
              cat "$log_file" >> error-log.txt
            else
              echo "‚úÖ Aucun log trouv√© pour $service." >> error-log.txt
            fi
          done

          if [[ "$LOGS_FOUND" == "true" ]]; then
            echo "ERROR_LOGS=true" >> $GITHUB_ENV
            git add error-log.txt
          else
            echo "ERROR_LOGS=false" >> $GITHUB_ENV
          fi

      - name: üöÄ D√©terminer la branche cible et Pousser les logs
        if: env.ERROR_LOGS == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
            git config --global user.name "GitHub Actions"
            git config --global user.email "github-actions@github.com"
        
            TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
            BRANCH="erreur-$TIMESTAMP"
        
            if git rev-parse --verify $BRANCH; then
              echo "La branche $BRANCH existe d√©j√†, on passe √† l'√©tape suivante."
            else
              git checkout -b $BRANCH
            fi
        
            git add error-log.txt
            git commit -m "Ajout des logs d'erreur via GitHub Actions" || echo "Aucune modification √† commit"
            git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $BRANCH --force
        
      - name: üîÄ V√©rifier l'existence de la PR et cr√©er une Pull Request vers `develop` si n√©cessaire
        if: env.ERROR_LOGS == 'false' || github.ref == 'refs/heads/develop'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
            # V√©rifier si une PR existe d√©j√† entre la branche actuelle et develop
            EXISTING_PR=$(gh pr list --base develop --head ${{ github.ref_name }} --state open --json number --jq '.[0].number')
            
            if [ -z "$EXISTING_PR" ]; then
              # Si aucune PR ouverte, cr√©er une nouvelle PR vers develop
              echo "Cr√©ation de la PR vers develop"
              gh pr create --base develop --head ${{ github.ref_name }} --title "Merge successful deployment" --body "Tous les services se sont d√©ploy√©s correctement. PR automatique vers develop."
            else
              echo "La PR vers develop existe d√©j√†. PR #$EXISTING_PR"
            fi
        