name: Docker Swarm CI

on:
  push:
    branches-ignore:
      - main
  pull_request:
    branches:
      - main

jobs:
  ###########################
  #      CONFIGURATION      #
  ###########################
  setup:
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Cloner le dépôt
        uses: actions/checkout@v4

      - name: ⚙️ Configurer Docker et Swarm
        run: docker swarm init || true

      - name: 🔎 Vérifier l'existence des fichiers Docker Compose
        run: |
          for service in suricata wazuh elk opencti; do
            if [[ ! -f "$service/docker-compose.yml" ]]; then
              echo "❌ Fichier manquant : $service/docker-compose.yml"
              exit 1
            fi
          done

      - name: 💾 Sauvegarder le workspace (avec `.git/`)
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: |
            .
            .git/
          retention-days: 1
          compression-level: 6

  ###########################
  #      DÉPLOIEMENT        #
  ###########################
  deploy:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - name: 🔄 Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: 🔎 Vérifier les fichiers après restauration
        run: |
          echo "📂 Vérification des fichiers après restauration..."
          ls -R
          for service in suricata wazuh elk opencti; do
            if [[ ! -f "$service/docker-compose.yml" ]]; then
              echo "❌ Fichier manquant après restauration : $service/docker-compose.yml"
              exit 1
            fi
          done

      - name: 🚀 Déployer les services
        run: |
          for service in suricata wazuh elk opencti; do
            docker stack deploy -c "$service/docker-compose.yml" "$service" 2>&1 | tee logs_$service.txt || echo "${service^^}_FAILED=true" >> $GITHUB_ENV
            sleep 10
          done


  ###########################
  #        NETTOYAGE        #
  ###########################
  cleanup:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: 🔄 Restaurer le workspace (optionnel si nécessaire)
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: 🗑️ Vérifier et Initialiser Swarm si nécessaire
        run: |
          if ! docker info | grep -q "Swarm: active"; then
            echo "⚠️ Swarm n'est pas actif, initialisation en cours..."
            docker swarm init || true
          fi

      - name: 🗑️ Nettoyer les services
        run: |
          for service in suricata wazuh elk opencti; do
            docker stack rm $service || true
          done

  ###########################
  #  DÉTECTION DES ERREURS  #
  ###########################
  check_errors:
    needs: deploy
    runs-on: ubuntu-latest
    outputs:
      test_failed: ${{ steps.detect_failure.outputs.test_failed }}
    steps:
      - name: 🔄 Restaurer le workspace avec logs
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: 🚨 Vérifier les erreurs
        id: detect_failure
        run: |
          echo "TEST_FAILED=false" >> $GITHUB_ENV

          for service in suricata wazuh elk opencti; do
            log_file="logs_$service.txt"
            if [[ -f "$log_file" && $(grep -i "error\|failed\|cannot" "$log_file") ]]; then
              echo "TEST_FAILED=true" >> $GITHUB_ENV
              echo "test_failed=true" >> $GITHUB_OUTPUT  # 🔥 Nouvelle méthode
              break
            fi
          done

  ###########################
  #   GESTION DES BRANCHES  #
  ###########################
  push_logs:
    needs: check_errors
    if: needs.check_errors.outputs.test_failed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: 🔄 Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: 🚀 Vérifier que `.git/` est bien restauré
        run: ls -la .git || echo "⚠️ Le dossier .git est manquant"

      - name: 🏷️ Déterminer la branche cible
        run: |
          if [[ "${{ needs.check_errors.outputs.test_failed }}" == "true" ]]; then
            TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
            echo "BRANCH=erreur-$TIMESTAMP" >> $GITHUB_ENV
          else
            echo "BRANCH=develop" >> $GITHUB_ENV
          fi

      - name: 📝 Générer le fichier de logs
        if: needs.check_errors.outputs.test_failed == 'true'
        run: |
          echo "═══════════════════════════════════════" > error-log.txt
          echo "              🛠️ LOG DU PIPELINE 🛠️              " >> error-log.txt
          echo "═══════════════════════════════════════" >> error-log.txt
          echo "📅 Date : $(date)" >> error-log.txt
          echo "═══════════════════════════════════════" >> error-log.txt

          echo "ℹ️  Docker Info :" >> error-log.txt
          docker info >> error-log.txt 2>&1
          
          echo "───────────────────────────────────────" >> error-log.txt
          echo "ℹ️  Docker Version :" >> error-log.txt
          docker version >> error-log.txt 2>&1

          echo "───────────────────────────────────────" >> error-log.txt
          echo "ℹ️  Liste des Stacks Docker :" >> error-log.txt
          docker stack ls >> error-log.txt 2>&1

          echo "───────────────────────────────────────" >> error-log.txt
          echo "ℹ️  Liste des Services Swarm :" >> error-log.txt
          docker service ls >> error-log.txt 2>&1

          echo "───────────────────────────────────────" >> error-log.txt
          echo "ℹ️  Liste des Conteneurs en cours d'exécution :" >> error-log.txt
          docker ps -a >> error-log.txt 2>&1

          echo "═══════════════════════════════════════" >> error-log.txt
          echo "❌ Logs détaillés des services échoués :" >> error-log.txt
          echo "═══════════════════════════════════════" >> error-log.txt

          for service in suricata wazuh elk opencti; do
            log_file="logs_$service.txt"
            if [[ -f "$log_file" ]]; then
              echo "───────────────────────────────────────" >> error-log.txt
              echo "❌ ERREUR DE DÉPLOIEMENT POUR $service :" >> error-log.txt
              echo "───────────────────────────────────────" >> error-log.txt
              cat "$log_file" >> error-log.txt
            fi
          done

          for service in suricata wazuh elk opencti; do
            if docker stack ps $service 2>/dev/null | grep -q "Failed\|Rejected\|Shutdown\|Complete"; then
              echo "───────────────────────────────────────" >> error-log.txt
              echo "🔍 Logs pour service: $service" >> error-log.txt
              docker service logs $service >> error-log.txt 2>&1
            else
              echo "⚠️ Service $service non actif ou introuvable, impossible de récupérer les logs." >> error-log.txt
            fi
          done

          echo "═══════════════════════════════════════" >> error-log.txt
          echo "📌 FIN DU LOG" >> error-log.txt
          echo "═══════════════════════════════════════" >> error-log.txt

          git add error-log.txt

      - name: 🚀 Pousser la branche cible
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions@github.com"

          git checkout -b ${{ env.BRANCH }}
          git commit -m "Mise à jour automatique via GitHub Actions" || echo "Aucune modification à commit"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git ${{ env.BRANCH }} --force
