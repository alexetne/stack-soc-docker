name: Docker Swarm CI

on:
  push:
    branches-ignore:
      - main
  pull_request:
    branches:
      - main
      
      ###########################
      #      CONFIGURATION      #
      ###########################
jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Cloner le dépôt
        uses: actions/checkout@v4

      - name: 🛠️ Charger les variables d'environnement
        run: |
          if [ -f elk/.env ]; then
            echo "Chargement des variables depuis elk/.env"
            set -a
            source elk/.env
            set +a
          else
            echo "❌ Fichier .env manquant dans elk"
            exit 1
          fi

      - name: ⚙️ Configurer Docker et Swarm
        run: docker swarm init || true

      - name: 🔎 Vérifier l'existence des fichiers Docker Compose
        run: |
          for service in elk; do
            if [[ ! -f "$service/docker-compose.yml" ]]; then
              echo "❌ Fichier manquant : $service/docker-compose.yml"
              exit 1
            fi
          done

      - name: 💾 Sauvegarder le workspace
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: |
            .
            .git/
          retention-days: 1

  ###########################
  #      DÉPLOIEMENT        #
  ###########################
  deploy:
    needs: setup
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [elk]
    steps:
      - name: 🔄 Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: 🚀 Déployer ${{ matrix.service }}
        run: |
          echo "🔄 Déploiement de ${{ matrix.service }}..."
          docker stack deploy -c ${{ matrix.service }}/docker-compose.yml ${{ matrix.service }} 2>&1 | tee logs_${{ matrix.service }}.txt
          sleep 10

      - name : DEBUG VARIABLES
        run: |
          echo "ES_MEM_LIMIT=${{ secrets.ES_MEM_LIMIT }}"
          echo "KB_MEM_LIMIT=${{ secrets.KB_MEM_LIMIT }}"


      - name: 📦 Stocker les logs de ${{ matrix.service }}
        uses: actions/upload-artifact@v4
        with:
          name: logs_${{ matrix.service }}
          path: logs_${{ matrix.service }}.txt

  ###########################
  #  DÉTECTION DES ERREURS  #
  ###########################
  check_errors:
    needs: deploy
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [elk]
    outputs:
      test_failed: ${{ steps.detect_failure.outputs.test_failed }}
    steps:
      - name: 📥 Récupérer les logs de ${{ matrix.service }}
        uses: actions/download-artifact@v4
        with:
          name: logs_${{ matrix.service }}
          path: .

      - name: 🔍 Vérifier les erreurs dans logs_${{ matrix.service }}.txt
        id: detect_failure
        run: |
          TEST_FAILED=false
          log_file="logs_${{ matrix.service }}.txt"
          
          if [[ -f "$log_file" && $(grep -i "error\|failed\|cannot\|swarm manager" "$log_file") ]]; then
            echo "⚠️ Erreur détectée dans $log_file"
            TEST_FAILED=true
          fi

          echo "test_failed=$TEST_FAILED" >> $GITHUB_OUTPUT

  ###########################
  #   GESTION DES LOGS      #
  ###########################
  push_logs:
    needs: check_errors
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: 🚀 Vérifier `.git/`
        run: |
          if [ ! -d ".git" ]; then
            echo "⚠️ Le dossier .git est manquant, reclonage en cours..."
            rm -rf ./*
            git clone https://github.com/${{ github.repository }}.git .
          fi

      - name: 📥 Télécharger tous les logs
        uses: actions/download-artifact@v4
        with:
          path: logs/

      - name: 📝 Vérifier et générer un fichier de logs consolidé
        run: |
          LOGS_FOUND=false
          echo "📅 Date : $(date)" > error-log.txt
          
          for service in wazuh elk; do
            log_file="logs/logs_$service/logs_$service.txt"
            
            if [[ -f "$log_file" ]]; then
              LOGS_FOUND=true
              echo "❌ ERREUR DE DÉPLOIEMENT POUR $service :" >> error-log.txt
              cat "$log_file" >> error-log.txt
            else
              echo "✅ Aucun log trouvé pour $service." >> error-log.txt
            fi
          done

          if [[ "$LOGS_FOUND" == "true" ]]; then
            echo "ERROR_LOGS=true" >> $GITHUB_ENV
            git add error-log.txt
          else
            echo "ERROR_LOGS=false" >> $GITHUB_ENV
          fi

      - name: 🚀 Déterminer la branche cible et Pousser les logs
        if: env.ERROR_LOGS == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions@github.com"

          TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
          BRANCH="erreur-$TIMESTAMP"

          git checkout -b $BRANCH || git checkout $BRANCH

          git commit -m "Ajout des logs d'erreur via GitHub Actions" || echo "Aucune modification à commit"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $BRANCH --force

      - name: 🔀 Créer une Pull Request vers `develop` si aucun log d'erreur n'est trouvé
        if: env.ERROR_LOGS == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr create --base develop --head ${{ github.ref_name }} --title "Merge successful deployment" --body "Tous les services se sont déployés correctement. PR automatique vers develop."
