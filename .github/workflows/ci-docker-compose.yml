name: Docker Swarm CI

on:
  push:
    branches-ignore:
      - main
  pull_request:
    branches:
      - main

jobs:
  ###########################
  #      CONFIGURATION      #
  ###########################
  setup:
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Cloner le dÃ©pÃ´t
        uses: actions/checkout@v4

      - name: âš™ï¸ VÃ©rifier et Initialiser Docker Swarm
        run: |
          if ! docker info | grep -q "Swarm: active"; then
            echo "âš ï¸ Swarm n'est pas actif, initialisation..."
            docker swarm init || true
          fi

      - name: ðŸ”Ž VÃ©rifier les fichiers Docker Compose
        run: |
          for service in suricata wazuh elk opencti; do
            if [[ ! -f "$service/docker-compose.yml" ]]; then
              echo "âŒ Fichier $service/docker-compose.yml introuvable."
              exit 1
            fi
          done

      - name: ðŸ’¾ Sauvegarder le workspace
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: |
            .
            .git/
          retention-days: 1

      - name: ðŸ’¾ Sauvegarder `.git/` sÃ©parÃ©ment
        uses: actions/upload-artifact@v4
        with:
          name: git-repo
          path: .git/
          retention-days: 1

  ###########################
  #      DÃ‰PLOIEMENT        #
  ###########################
  deploy:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ”„ Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      # DÃ©ploiement sÃ©parÃ© pour chaque service
      - name: ðŸš€ DÃ©ploiement de Suricata
        run: |
          docker stack deploy -c suricata/docker-compose.yml suricata 2>&1 | tee logs_suricata.txt || echo "SURICATA_FAILED=true" >> $GITHUB_ENV
          sleep 5
      - name: ðŸ“¦ Stocker les logs de Suricata
        uses: actions/upload-artifact@v4
        with:
          name: logs_suricata
          path: logs_suricata.txt

      - name: ðŸš€ DÃ©ploiement de Wazuh
        run: |
          docker stack deploy -c wazuh/docker-compose.yml wazuh 2>&1 | tee logs_wazuh.txt || echo "WAZUH_FAILED=true" >> $GITHUB_ENV
          sleep 5
      - name: ðŸ“¦ Stocker les logs de Wazuh
        uses: actions/upload-artifact@v4
        with:
          name: logs_wazuh
          path: logs_wazuh.txt

      - name: ðŸš€ DÃ©ploiement de ELK
        run: |
          docker stack deploy -c elk/docker-compose.yml elk 2>&1 | tee logs_elk.txt || echo "ELK_FAILED=true" >> $GITHUB_ENV
          sleep 5
      - name: ðŸ“¦ Stocker les logs de ELK
        uses: actions/upload-artifact@v4
        with:
          name: logs_elk
          path: logs_elk.txt

      - name: ðŸš€ DÃ©ploiement de OpenCTI
        run: |
          docker stack deploy -c opencti/docker-compose.yml opencti 2>&1 | tee logs_opencti.txt || echo "OPENCTI_FAILED=true" >> $GITHUB_ENV
          sleep 5
      - name: ðŸ“¦ Stocker les logs de OpenCTI
        uses: actions/upload-artifact@v4
        with:
          name: logs_opencti
          path: logs_opencti.txt

  ###########################
  #        NETTOYAGE        #
  ###########################
  cleanup:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: ðŸ”„ Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: ðŸ—‘ï¸ VÃ©rifier et Initialiser Swarm si nÃ©cessaire
        run: |
          if ! docker info | grep -q "Swarm: active"; then
            echo "âš ï¸ Swarm n'est pas actif, initialisation en cours..."
            docker swarm init || { echo "âŒ Ã‰chec de l'initialisation de Swarm"; exit 1; }
          else
            echo "âœ… Swarm est dÃ©jÃ  actif."
          fi

      - name: ðŸ—‘ï¸ Nettoyer les services
        run: |
          if ! docker info | grep -q "Swarm: active"; then
            echo "âŒ Swarm n'est toujours pas actif, impossible de nettoyer les services."
            exit 1
          fi

          echo "ðŸ—‘ï¸ VÃ©rification des stacks existantes..."
          docker stack ls
          for service in suricata wazuh elk opencti; do
            if docker stack ls | grep -q "$service"; then
              echo "ðŸ—‘ï¸ Suppression de la stack $service..."
              docker stack rm $service || echo "âš ï¸ Erreur lors de la suppression de $service"
            else
              echo "âš ï¸ Stack $service introuvable, rien Ã  supprimer."
            fi
          done

  ###########################
  #  DÃ‰TECTION DES ERREURS  #
  ###########################
  check_errors:
    needs: deploy
    runs-on: ubuntu-latest
    outputs:
      test_failed: ${{ steps.detect_failure.outputs.test_failed }}
    steps:
      - name: ðŸ“¥ RÃ©cupÃ©rer les logs
        uses: actions/download-artifact@v4
        with:
          name: logs_suricata
          path: .
      - uses: actions/download-artifact@v4
        with:
          name: logs_wazuh
          path: .
      - uses: actions/download-artifact@v4
        with:
          name: logs_elk
          path: .
      - uses: actions/download-artifact@v4
        with:
          name: logs_opencti
          path: .

      - name: ðŸš¨ VÃ©rifier les erreurs
        id: detect_failure
        run: |
          TEST_FAILED=false
          
          for service in suricata wazuh elk opencti; do
            log_file="logs_$service.txt"
            if [[ -f "$log_file" && $(grep -i "error\|failed\|cannot\|swarm manager" "$log_file") ]]; then
              echo "âš ï¸ Erreur dÃ©tectÃ©e dans $log_file"
              TEST_FAILED=true
            fi
          done

          echo "test_failed=$TEST_FAILED" >> $GITHUB_ENV
          echo "test_failed=$TEST_FAILED" >> $GITHUB_OUTPUT

  ###########################
  #   GESTION DES BRANCHES  #
  ###########################
  push_logs:
    needs: check_errors
    if: needs.check_errors.outputs.test_failed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Cloner le dÃ©pÃ´t (obligatoire pour Git)
        uses: actions/checkout@v4

      - name: ðŸ”„ Restaurer le workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: ðŸš€ VÃ©rifier `.git/`
        run: ls -la .git || echo "âš ï¸ Le dossier .git est manquant"

      - name: ðŸ·ï¸ DÃ©terminer la branche cible
        run: |
          TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
          echo "BRANCH=erreur-$TIMESTAMP" >> $GITHUB_ENV

      - name: ðŸ“¥ RÃ©cupÃ©rer les logs
        uses: actions/download-artifact@v4
        with:
          name: logs_suricata
          path: .
      - uses: actions/download-artifact@v4
        with:
          name: logs_wazuh
          path: .
      - uses: actions/download-artifact@v4
        with:
          name: logs_elk
          path: .
      - uses: actions/download-artifact@v4
        with:
          name: logs_opencti
          path: .

      - name: ðŸš€ Pousser la branche cible
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions@github.com"

          git fetch origin
          git checkout -b ${{ env.BRANCH }} || git checkout ${{ env.BRANCH }}

          git add logs_*.txt
          git commit -m "Mise Ã  jour automatique via GitHub Actions - Logs dÃ©taillÃ©s par service" || echo "Aucune modification Ã  commit"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git ${{ env.BRANCH }} --force
